# Lock(锁)

### 认识

1. 解释

   ```tex
   计算机协调多个进程或线程并发访问某一资源的机制。
   ```

2. 重要性

   ```tex
   在数据库中，除传统计算资源（CPU、RAM、I\O等）的争抢，数据也是一种供多用户共享的资源。
   如何保证数据并发访问的一致性，有效性，是所有数据库必须要解决的问题。
   锁冲突也是影响数据库并发访问性能的一个重要因素，因此锁对数据库尤其重要。
   ```

3. 缺点

   ```tex
   加锁是消耗资源的，锁的各种操作，包括获得锁、检测锁是否已解除、释放锁等 ，都会增加系统的开销。
   ```

### 类型

|                |                             表锁                             |                             行锁                             |
| :------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|      种类      | 读锁（read lock \| shared lock）针对同一份数据，多个读操作同时进行互不影响<br />写锁（write lock \| exclusive lock）当前操作未完成之前会阻塞其他操作 | 读锁（read lock\|shared lock）允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁<br />写锁（write lock\|exclusive lock）允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享锁和排他锁<br />意向共享锁（IS）一个事务给一个数据行加共享锁时，必须先获得表的IS锁<br />意向排他锁（IX）一个事务给一个数据行加排他锁时，必须先获得表的IX锁 |
| 存储引擎默认锁 |                            MyISAM                            |                            Innodb                            |
|      特点      | 对整张表加锁<br />开销小<br />加锁快<br />无死锁<br />锁粒度大，锁冲突概率大，并发性低 | 对一行数据加锁<br />开销大<br />加锁慢<br />有死锁<br />锁粒度小，锁冲突概率小，并发性高 |

### InnoDB 锁模式

1. InnoDB实现了两种模式的**行锁**：

   + 共享锁（s）：允许一个事务读取一行，阻止其他事务获取相同数据集的排他锁。
   + 排他锁（x）：允许获得排他锁的事务更新数据，阻止其他事务获取相同数据集的共享读锁和排他写锁。

2. 为了表锁行锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），意向锁都是表锁：

   + 意向共享锁（IS）：事务打算给数据行加共享锁，必须先获得该表的 IS 锁。
   + 意向排他锁（IX）：事务打算给数据行加排他锁，必须先获取该表的 IX 锁。

3. 锁模式兼容性：

   | ---  |  X   |  IX  |  S   |  IS  |
   | :--: | :--: | :--: | :--: | :--: |
   |  X   | 冲突 | 冲突 | 冲突 | 冲突 |
   |  IX  | 冲突 | 兼容 | 冲突 | 兼容 |
   |  S   | 冲突 | 冲突 | 兼容 | 兼容 |
   |  IS  | 冲突 | 兼容 | 兼容 | 兼容 |

   注：列为当前锁，行为请求锁。

### 行锁的实现算法

1. Record Lock 单行记录上的锁

   ```
   Record Lock 总是会去锁住索引记录，如果InnoDB引擎表建立的时候没有设置任何一个索引，那么存储引擎会使用隐式的主键进行锁定。
   ```

2. Gap Lock 锁

   ```
   当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引加锁，对于键值在条件范围内但并不存在的记录也会加锁。
   
   优点：解决了事务并发的幻读问题
   不足：因为query执行过程中通过范围查找的话，他会锁定争个范围内所有的索引键值，即使这个键值并不存在。
   间隙锁有一个致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成锁定的时候无法插入锁定键值范围内任何数据。在某些场景下这可能会对性能造成很大的危害。
   ```

3. Next-key Lock 锁

   ```
   同时锁住数据+间隙锁
   在Repeatable Read隔离级别下，Next-key Lock 算法是默认的行记录锁定算法。
   ```

   **行锁tips**

   ```
   1. 只有通过索引条件检索数据时，InnoDB才会使用行级锁，否则会使用表级锁(索引失效，行锁变表锁)
   2. 即使是访问不同行的记录，如果使用的是相同的索引键，会发生锁冲突
   3. 如果数据表建有多个索引时，可以通过不同的索引锁定不同的行
   ```

### 死锁

1. 解释

   ```
   指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象
   ```

2. 产生条件

   ```
   1. 互斥条件：一个资源每次只能被一个进程使用
   2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
   3. 不剥夺条件：进程已获得的资源，在没有使用完之前，不能强行剥夺
   4. 循环等待条件：多个进程之间形成的一种互相循环等待的资源的关系
   ```

3. 解决

   ```
   1. 查看死锁：show engine innodb status \G
   2. 自动检测机制，超时自动回滚代价较小的事务（innodb_lock_wait_timeout 默认50s）
   3. 人为解决，kill阻塞进程（show processlist）
   4. wait for graph 等待图（主动检测）
   ```

4. 如何避免

   ```
   1. 加锁顺序一致，尽可能一次性锁定所需的数据行
   2. 尽量基于primary（主键）或unique key更新数据
   3. 单次操作数据量不宜过多，涉及表尽量少
   4. 减少表上索引，减少锁定资源
   5. 尽量使用较低的隔离级别
   6. 尽量使用相同条件访问数据，这样可以避免间隙锁对并发的插入影响
   7. 精心设计索引，尽量使用索引访问数据
   ```

### 乐观锁和悲观锁

|          |                        悲观锁                        |                           乐观锁                           |
| :------: | :--------------------------------------------------: | :--------------------------------------------------------: |
|   概念   | 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 | 假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性 |
| 实现机制 |      查询时直接锁住记录使其他事务不能查询和更新      |             提交更新时检查版本或时间戳是否符合             |
| 实现方式 |                      表锁、行锁                      |                  用version或timestamp比较                  |
|  实现者  |                        数据库                        |                           开发者                           |
| 适用场景 |                       并发量大                       |                          并发量小                          |

